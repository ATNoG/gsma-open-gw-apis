/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Health */
        get: operations["get_health_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/one-time-password-sms/v1/send-code": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Send Code */
        post: operations["send_code_one_time_password_sms_v1_send_code_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/one-time-password-sms/v1/validate-code": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Send Code */
        post: operations["send_code_one_time_password_sms_v1_validate_code_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/qos-profiles/v1/retrieve-qos-profiles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retrieve Qos Profiles */
        post: operations["retrieve_qos_profiles_qos_profiles_v1_retrieve_qos_profiles_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/qos-profiles/v1/qos-profiles/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve Qos Profile By Name */
        get: operations["retrieve_qos_profile_by_name_qos_profiles_v1_qos_profiles__name__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/location-retrieval/v0.4/retrieve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retrieve Location */
        post: operations["retrieve_location_location_retrieval_v0_4_retrieve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/location-verification/v2/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retrieve Location */
        post: operations["retrieve_location_location_verification_v2_verify_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/qod-provisioning/v0.2/device-qos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Provisioning */
        post: operations["create_provisioning_qod_provisioning_v0_2_device_qos_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/qod-provisioning/v0.2/device-qos/{provisioningId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Qod Information By Id */
        get: operations["get_qod_information_by_id_qod_provisioning_v0_2_device_qos__provisioningId__get"];
        put?: never;
        post?: never;
        /** Delete Qod */
        delete: operations["delete_qod_qod_provisioning_v0_2_device_qos__provisioningId__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/qod-provisioning/v0.2/retrieve-device-qos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Get Qod Information By Id */
        post: operations["get_qod_information_by_id_qod_provisioning_v0_2_retrieve_device_qos_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/geofencing-subscriptions/v0.4/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Subscription */
        get: operations["get_subscription_geofencing_subscriptions_v0_4_subscriptions_get"];
        put?: never;
        /** Post Subscriptions */
        post: operations["post_subscriptions_geofencing_subscriptions_v0_4_subscriptions_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/geofencing-subscriptions/v0.4/subscriptions/{subscriptionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Subscriptions By Id */
        get: operations["get_subscriptions_by_id_geofencing_subscriptions_v0_4_subscriptions__subscriptionId__get"];
        put?: never;
        post?: never;
        /** Delete Subscriptions By Id */
        delete: operations["delete_subscriptions_by_id_geofencing_subscriptions_v0_4_subscriptions__subscriptionId__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/device-reachability-status/v1/retrieve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retrieve Reachability Status */
        post: operations["retrieve_reachability_status_device_reachability_status_v1_retrieve_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/device-reachability-status-subscriptions/v0.7/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Subscription */
        get: operations["get_subscription_device_reachability_status_subscriptions_v0_7_subscriptions_get"];
        put?: never;
        /** Post Subscriptions */
        post: operations["post_subscriptions_device_reachability_status_subscriptions_v0_7_subscriptions_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/device-reachability-status-subscriptions/v0.7/subscriptions/{subscriptionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Subscriptions By Id */
        get: operations["get_subscriptions_by_id_device_reachability_status_subscriptions_v0_7_subscriptions__subscriptionId__get"];
        put?: never;
        post?: never;
        /** Delete Subscriptions By Id */
        delete: operations["delete_subscriptions_by_id_device_reachability_status_subscriptions_v0_7_subscriptions__subscriptionId__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** AMQPSettings */
        AMQPSettings: {
            /** Address */
            address?: string | null;
            /** Linkname */
            linkName?: string | null;
            senderSettlementMode?: components["schemas"]["SenderSettlementMode"] | null;
            /** Linkproperties */
            linkProperties?: {
                [key: string]: string;
            } | null;
        };
        /** AMQPSubscriptionRequest[SubscriptionEventType, Config] */
        AMQPSubscriptionRequest_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "AMQP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Input"];
            protocolSettings?: components["schemas"]["AMQPSettings"] | null;
        };
        /** AMQPSubscriptionRequest[SubscriptionEventType, SubscriptionConfig] */
        AMQPSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "AMQP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Input"];
            protocolSettings?: components["schemas"]["AMQPSettings"] | null;
        };
        /** AMQPSubscriptionResponse[SubscriptionEventType, Config] */
        AMQPSubscriptionResponse_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "AMQP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["AMQPSettings"] | null;
        };
        /** AMQPSubscriptionResponse[SubscriptionEventType, SubscriptionConfig] */
        AMQPSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "AMQP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["AMQPSettings"] | null;
        };
        /** ApacheKafkaSettings */
        ApacheKafkaSettings: {
            /** Topicname */
            topicName: string;
            /** Partitionkeyextractor */
            partitionKeyExtractor?: string | null;
            /** Clientid */
            clientId?: string | null;
            /** Ackmode */
            ackMode?: number | null;
        };
        /** ApacheKafkaSubscriptionRequest[SubscriptionEventType, Config] */
        ApacheKafkaSubscriptionRequest_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "KAFKA";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Input"];
            protocolSettings?: components["schemas"]["ApacheKafkaSettings"] | null;
        };
        /** ApacheKafkaSubscriptionRequest[SubscriptionEventType, SubscriptionConfig] */
        ApacheKafkaSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "KAFKA";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Input"];
            protocolSettings?: components["schemas"]["ApacheKafkaSettings"] | null;
        };
        /** ApacheKafkaSubscriptionResponse[SubscriptionEventType, Config] */
        ApacheKafkaSubscriptionResponse_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "KAFKA";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["ApacheKafkaSettings"] | null;
        };
        /** ApacheKafkaSubscriptionResponse[SubscriptionEventType, SubscriptionConfig] */
        ApacheKafkaSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "KAFKA";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["ApacheKafkaSettings"] | null;
        };
        /** Area */
        Area: {
            areaType: components["schemas"]["AreaType"];
        };
        /**
         * AreaType
         * @enum {string}
         */
        AreaType: "CIRCLE" | "POLYGON";
        /** Circle */
        "Circle-Output": {
            /**
             * Areatype
             * @default CIRCLE
             * @constant
             */
            areaType: "CIRCLE";
            center: components["schemas"]["Point"];
            /**
             * Radius
             * @description Expected accuracy for the subscription event of device location, in meters from `center`.
             *     Note: The area surface could be restricted locally depending on regulations. Implementations may enforce a larger minimum radius (e.g. 1000 meters).
             *
             */
            radius: number;
        };
        /** Config */
        "Config-Input": {
            subscriptionDetail: components["schemas"]["SubscriptionDetail-Input"];
            /** Subscriptionexpiretime */
            subscriptionExpireTime?: string | null;
            /** Subscriptionmaxevents */
            subscriptionMaxEvents?: number | null;
            /** Initialevent */
            initialEvent?: boolean | null;
        };
        /** Config */
        "Config-Output": {
            subscriptionDetail: components["schemas"]["SubscriptionDetail-Output"];
            /** Subscriptionexpiretime */
            subscriptionExpireTime?: string | null;
            /** Subscriptionmaxevents */
            subscriptionMaxEvents?: number | null;
            /** Initialevent */
            initialEvent?: boolean | null;
        };
        /**
         * ConnectivityType
         * @enum {string}
         */
        ConnectivityType: "DATA" | "SMS";
        /** CreateSubscriptionDetail */
        "CreateSubscriptionDetail-Input": {
            device?: components["schemas"]["app__schemas__device__Device-Input"] | null;
        };
        /** CreateSubscriptionDetail */
        "CreateSubscriptionDetail-Output": {
            device?: components["schemas"]["Device-Output"] | null;
        };
        /**
         * CredentialType
         * @enum {string}
         */
        CredentialType: "PLAIN" | "ACCESSTOKEN" | "REFRESHTOKEN";
        /** Device */
        "Device-Output": {
            /** Phonenumber */
            phoneNumber?: string | null;
            /** Networkaccessidentifier */
            networkAccessIdentifier?: string | null;
            ipv4Address?: components["schemas"]["DeviceIpv4Addr-Output"] | null;
            /** Ipv6Address */
            ipv6Address?: string | null;
        };
        /** DeviceIpv4Addr */
        "DeviceIpv4Addr-Output": {
            /**
             * Publicaddress
             * Format: ipv4
             * @description A single IPv4 address with no subnet mask
             */
            publicAddress: string;
            /** Privateaddress */
            privateAddress?: string | null;
            /** Publicport */
            publicPort?: number | null;
        };
        /** DeviceIpv4Addr1 */
        DeviceIpv4Addr1: {
            /**
             * Publicaddress
             * Format: ipv4
             */
            publicAddress: string;
            /**
             * Privateaddress
             * Format: ipv4
             */
            privateAddress: string;
            /** Publicport */
            publicPort?: number | null;
        };
        /** DeviceIpv4Addr2 */
        DeviceIpv4Addr2: {
            /**
             * Publicaddress
             * Format: ipv4
             */
            publicAddress: string;
            /** Privateaddress */
            privateAddress?: string | null;
            /**
             * Publicport
             * @description TCP or UDP port number
             */
            publicPort: number;
        };
        /** Duration */
        Duration: {
            /**
             * Value
             * @description Quantity of duration
             */
            value?: number | null;
            unit?: components["schemas"]["TimeUnitEnum"] | null;
        };
        /** ErrorInfo */
        ErrorInfo: {
            /**
             * Status
             * @description HTTP response status code
             */
            status: number;
            /**
             * Code
             * @description Code given to this error
             */
            code: string;
            /**
             * Message
             * @description Detailed error description
             */
            message: string;
        };
        /** HTTPSettings */
        HTTPSettings: {
            /**
             * Headers
             * @description A set of key/value pairs that is copied into the HTTP request as custom headers.
             *
             *     NOTE: Use/Applicability of this concept has not been discussed in Commonalities under the scope of Meta Release v0.4. When required by an API project as an option to meet a UC/Requirement, please generate an issue for Commonalities discussion about it.
             */
            headers?: {
                [key: string]: string;
            } | null;
            /** @description The HTTP method to use for sending the message. */
            method?: components["schemas"]["Method"] | null;
        };
        /** HTTPSubscriptionRequest[SubscriptionEventType, Config] */
        HTTPSubscriptionRequest_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "HTTP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Input"];
            protocolSettings?: components["schemas"]["HTTPSettings"] | null;
        };
        /** HTTPSubscriptionRequest[SubscriptionEventType, SubscriptionConfig] */
        HTTPSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "HTTP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Input"];
            protocolSettings?: components["schemas"]["HTTPSettings"] | null;
        };
        /** HTTPSubscriptionResponse[SubscriptionEventType, Config] */
        HTTPSubscriptionResponse_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "HTTP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["HTTPSettings"] | null;
        };
        /** HTTPSubscriptionResponse[SubscriptionEventType, SubscriptionConfig] */
        HTTPSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "HTTP";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["HTTPSettings"] | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * L4sQueueType
         * @enum {string}
         */
        L4sQueueType: "non-l4s-queue" | "l4s-queue" | "mixed-queue";
        /** Location */
        Location: {
            /**
             * Lastlocationtime
             * Format: date-time
             * @description Last date and time when the device was localized. It must follow RFC 3339 and must have time zone. Recommended format is yyyy-MM-dd'T'HH:mm:ss.SSSZ (i.e. which allows 2023-07-03T14:27:08.312+02:00 or 2023-07-03T12:27:08.312Z)
             */
            lastLocationTime: string;
            area: components["schemas"]["Area"];
        };
        /** MQTTSettings */
        MQTTSettings: {
            /** Topicname */
            topicName: string;
            /** Qos */
            qos?: number | null;
            /** Retain */
            retain?: boolean | null;
            /** Expiry */
            expiry?: number | null;
            /** Userproperties */
            userProperties?: {
                [key: string]: unknown;
            } | null;
        };
        /** MQTTSubscriptionRequest[SubscriptionEventType, Config] */
        MQTTSubscriptionRequest_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "MQTT3" | "MQTT5";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Input"];
            protocolSettings?: components["schemas"]["MQTTSettings"] | null;
        };
        /** MQTTSubscriptionRequest[SubscriptionEventType, SubscriptionConfig] */
        MQTTSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "MQTT3" | "MQTT5";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Input"];
            protocolSettings?: components["schemas"]["MQTTSettings"] | null;
        };
        /** MQTTSubscriptionResponse[SubscriptionEventType, Config] */
        MQTTSubscriptionResponse_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "MQTT3" | "MQTT5";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["MQTTSettings"] | null;
        };
        /** MQTTSubscriptionResponse[SubscriptionEventType, SubscriptionConfig] */
        MQTTSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "MQTT3" | "MQTT5";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["MQTTSettings"] | null;
        };
        /**
         * Method
         * @enum {string}
         */
        Method: "POST";
        /** NATSSettings */
        NATSSettings: {
            /** Subject */
            subject: string;
        };
        /** NATSSubscriptionRequest[SubscriptionEventType, Config] */
        NATSSubscriptionRequest_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "NATS";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Input"];
            protocolSettings?: components["schemas"]["NATSSettings"] | null;
        };
        /** NATSSubscriptionRequest[SubscriptionEventType, SubscriptionConfig] */
        NATSSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "NATS";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types which are eligible to be delivered by this subscription.
             *     Note: As of now we enforce to have only event type per subscription.
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Input"];
            protocolSettings?: components["schemas"]["NATSSettings"] | null;
        };
        /** NATSSubscriptionResponse[SubscriptionEventType, Config] */
        NATSSubscriptionResponse_SubscriptionEventType_Config_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "NATS";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__geofencing__SubscriptionEventType"][];
            config: components["schemas"]["Config-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["NATSSettings"] | null;
        };
        /** NATSSubscriptionResponse[SubscriptionEventType, SubscriptionConfig] */
        NATSSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            protocol: "NATS";
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink: string;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Types
             * @description Camara Event types eligible to be delivered by this subscription.
             *
             */
            types: components["schemas"]["app__schemas__reachability_status__SubscriptionEventType"][];
            config: components["schemas"]["SubscriptionConfig-Output"];
            /**
             * Id
             * @description The unique identifier of the subscription in the scope of the subscription manager. When this information is contained within an event notification, this concept SHALL be referred as `subscriptionId` as per [Commonalities Event Notification Model](https://github.com/camaraproject/Commonalities/blob/main/documentation/API-design-guidelines.md#122-event-notification).
             */
            id: string;
            /**
             * Startsat
             * Format: date-time
             * @description Date when the event subscription will begin/began.
             */
            startsAt: string;
            /** Expiresat */
            expiresAt?: string | null;
            status?: components["schemas"]["SubscriptionStatus"] | null;
            protocolSettings?: components["schemas"]["NATSSettings"] | null;
        };
        /** Point */
        Point: {
            /**
             * Latitude
             * @description Latitude component of a location.
             */
            latitude: number;
            /**
             * Longitude
             * @description Longitude component of location.
             */
            longitude: number;
        };
        /** ProvisioningInfo */
        ProvisioningInfo: {
            device: components["schemas"]["Device-Output"] | null;
            /**
             * Qosprofile
             * @description A unique name for identifying a specific QoS profile.
             *     This may follow different formats depending on the service providers implementation.
             *     Some options addresses:
             *       - A UUID style string
             *       - Support for predefined profiles QOS_S, QOS_M, QOS_L, and QOS_E
             *       - A searchable descriptive name
             *     The set of QoS Profiles that an operator is offering can be retrieved by means of the [QoS Profile API](link TBC).
             *
             */
            qosProfile: string;
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink?: string | null;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
            /**
             * Provisioningid
             * Format: uuid
             * @description Provisioning Identifier in UUID format
             */
            provisioningId: string;
            /**
             * Startedat
             * @description Date and time when the provisioning became "AVAILABLE". Not to be returned when `status` is "REQUESTED". Format must follow RFC 3339 and must indicate time zone (UTC or local).
             */
            startedAt?: string | null;
            status: components["schemas"]["Status"];
            statusInfo?: components["schemas"]["StatusInfo"] | null;
        };
        /** QosProfile */
        QosProfile: {
            /**
             * Name
             * @description A unique name for identifying a specific QoS profile.
             *     This may follow different formats depending on the service providers implementation.
             *     Some options addresses:
             *       - A UUID style string
             *       - Support for predefined profile names like `QOS_E`, `QOS_S`, `QOS_M`, and `QOS_L`
             *       - A searchable descriptive name
             */
            name: string;
            /**
             * Description
             * @description A description of the QoS profile.
             */
            description?: string | null;
            status: components["schemas"]["QosProfileStatus"];
            /** @description This is the target minimum upload speed for the QoS profile.
             *     It represents the minimum rate that the network attempts to deliver.
             *     Please note that this is a target value—the network might not always be able to provide this rate under all conditions.
             *     It helps ensure that applications like video calls or live streaming perform consistently. */
            targetMinUpstreamRate?: components["schemas"]["Rate"] | null;
            /** @description The maximum best effort data */
            maxUpstreamRate?: components["schemas"]["Rate"] | null;
            /** @description When defined, this is the maximum upstream burst rate for the QoS profile, that will enable
             *     the network to burst data at a higher rate than the maxUpstreamRate for a period of time. */
            maxUpstreamBurstRate?: components["schemas"]["Rate"] | null;
            /** @description This is the target maximum upload speed for the QoS profile.
             *     It represents the maximum rate that the network attempts to deliver.
             *     Please note that this is a target value—the network might not always be able to provide this rate under all conditions.
             *     It helps ensure that applications like video calls or live streaming perform consistently. */
            targetMinDownstreamRate?: components["schemas"]["Rate"] | null;
            /** @description The maximum best effort rate */
            maxDownstreamRate?: components["schemas"]["Rate"] | null;
            /** @description When defined, this is the maximum downstream burst rate for the QoS profile, that will enable
             *     the network to burst data at a higher rate than the maxDownstreamRate for a period of time.
             *     This can result in improved user experience when there is additional network capacity.
             *     For instance, when a user is streaming a video, the network can burst data at a higher rate
             *     to fill the buffer, and then return to the maxUpstreamRate once the buffer is full. */
            maxDownstreamBurstRate?: components["schemas"]["Rate"] | null;
            /** @description The shortest time period that this profile can be deployed. */
            minDuration?: components["schemas"]["Duration"] | null;
            /** @description The maximum time period that this profile can be deployed.
             *     Overall session duration must not exceed this value. This includes the initial requested duration plus any extensions. */
            maxDuration?: components["schemas"]["Duration"] | null;
            /**
             * Priority
             * @description Priority levels allow efficient resource allocation and ensure optimal performance
             *     for various services in each technology, with the highest priority traffic receiving
             *     preferential treatment.
             *     The lower value the higher priority.
             *     Not all access networks use the same priority range, so this priority will be
             *     scaled to the access network's priority range.
             */
            priority?: number | null;
            /** @description The packet delay budget is the maximum allowable one-way latency between the customer's device
             *     and the gateway from the operator's network to other networks. By limiting the delay, the network
             *     can provide an acceptable level of performance for various services, such as voice calls,
             *     video streaming, and data.
             *     The end-to-end or round trip latency will be about two times this value plus the latency not controlled
             *     by the operator */
            packetDelayBudget?: components["schemas"]["Duration"] | null;
            /** @description The jitter requirement aims to limit the maximum variation in round-trip
             *     packet delay for the 99th percentile of traffic, following ITU Y.1540
             *     standards. It considers only acknowledged packets in a session, which are
             *     packets that receive a confirmation of receipt from the recipient (e.g.,
             *     using TCP). This requirement helps maintain consistent latency, essential
             *     for real-time applications such as VoIP, video calls, and gaming. */
            jitter?: components["schemas"]["Duration"] | null;
            /**
             * Packeterrorlossrate
             * @description This field specifies the acceptable level of data loss during transmission.
             *     The value is an exponent of 10, so a value of 3 means that up to 10⁻³, or 0.1%, of the
             *     data packets may be lost. This setting is part of a broader system that categorizes
             *     different types of network traffic (like phone calls, video streams, or data transfers)
             *     to ensure they perform reliably on the network.
             */
            packetErrorLossRate?: number | null;
            /** @description
             *     **NOTE**: l4sQueueType is experimental and could change or be removed in a future release.
             *
             *     Specifies the type of queue for L4S (Low Latency, Low Loss, Scalable Throughput) traffic management. L4S is an advanced queue management approach designed to provide ultra-low latency and high throughput for internet traffic, particularly beneficial for interactive applications such as gaming, video conferencing, and virtual reality.
             *
             *     **Queue Type Descriptions:**
             *
             *     - **non-l4s-queue**:
             *       A traditional queue used for legacy internet traffic that does not utilize L4S enhancements. It provides standard latency and throughput levels.
             *
             *     - **l4s-queue**:
             *       A dedicated queue optimized for L4S traffic, delivering ultra-low latency, low loss, and scalable throughput to support latency-sensitive applications.
             *
             *     - **mixed-queue**:
             *       A shared queue that can handle both L4S and traditional traffic, offering a balance between ultra-low latency for L4S flows and compatibility with non-L4S flows. */
            l4sQueueType?: components["schemas"]["L4sQueueType"] | null;
            /** @description
             *     **NOTE**: serviceClass is experimental and could change or be removed in a future release.
             *
             *     The name of a Service Class, representing a QoS Profile designed to provide optimized behavior for a specific application type. While DSCP values are commonly associated with Service Classes, their use may vary across network segments and may not be applied throughout the entire end-to-end QoS session. This aligns with the serviceClass concept used in HomeDevicesQoQ for consistent terminology.
             *
             *     Service classes define specific QoS behaviors that map to DSCP (Differentiated Services Code Point) values or Microsoft QoS traffic types.
             *
             *     The supported mappings are:
             *     1. Values aligned with the [RFC4594](https://datatracker.ietf.org/doc/html/rfc4594) guidelines for differentiated traffic classes.
             *     2. Microsoft [QOS_TRAFFIC_TYPE](https://learn.microsoft.com/en-us/windows/win32/api/qos2/ne-qos2-qos_traffic_type) values for Windows developers.
             *
             *     **Supported Service Classes**:
             *
             *     | Service Class Name    | DSCP Name | DSCP value (decimal) | DCSP value (binary) | Microsoft Value | Application Examples                                                 |
             *     |-----------------------|-----------|----------------------|---------------------|-----------------|----------------------------------------------------------------------|
             *     | Microsoft Voice       |    CS7    |          56          |        111000       |       4,5       | Microsoft QOSTrafficTypeVoice and QOSTrafficTypeControl              |
             *     | Microsoft Audio/Video |    CS5    |          40          |        101000       |       2,3       | Microsoft QOSTrafficTypeExcellentEffort and QOSTrafficTypeAudioVideo |
             *     | Real-Time Interactive |    CS4    |          32          |        100000       |                 | Video conferencing and Interactive gaming                            |
             *     | Multimedia Streaming  |    AF31   |          26          |        011010       |                 | Streaming video and audio on demand                                  |
             *     | Broadcast Video       |    CS3    |          24          |        011000       |                 | Broadcast TV & live events                                           |
             *     | Low-Latency Data      |    AF21   |          18          |        010010       |                 | Client/server transactions Web-based ordering                        |
             *     | High-Throughput Data  |    AF11   |          10          |        001010       |                 | Store and forward applications                                       |
             *     | Low-Priority Data     |    CS1    |           8          |        001000       |        1        | Any flow that has no BW assurance - also:                            |
             *     |                       |           |                      |                     |                 | Microsoft QOSTrafficTypeBackground                                   |
             *     | Standard              |  DF(CS0)  |           0          |        000000       |        0        | Undifferentiated applications - also:                                |
             *     |                       |           |                      |                     |                 | Microsoft QOSTrafficTypeBestEffort                                   | */
            serviceClass?: components["schemas"]["ServiceClass"] | null;
        };
        /** QosProfileDeviceRequest */
        QosProfileDeviceRequest: {
            device?: components["schemas"]["app__schemas__qos_profiles__Device"] | null;
            /** Name */
            name?: string | null;
            status?: components["schemas"]["QosProfileStatus"] | null;
        };
        /**
         * QosProfileStatus
         * @enum {string}
         */
        QosProfileStatus: "ACTIVE" | "INACTIVE" | "DEPRECATED";
        /** Rate */
        Rate: {
            /**
             * Value
             * @description Quantity of rate
             */
            value?: number | null;
            unit?: components["schemas"]["RateUnitEnum"] | null;
        };
        /**
         * RateUnitEnum
         * @enum {string}
         */
        RateUnitEnum: "bps" | "kbps" | "Mbps" | "Gbps" | "Tbps";
        /** ReachabilityStatusResponse */
        ReachabilityStatusResponse: {
            /** Laststatustime */
            lastStatusTime?: string | null;
            /**
             * Reachable
             * @description Indicates overall device reachability
             */
            reachable: boolean;
            /** Connectivity */
            connectivity?: components["schemas"]["ConnectivityType"][] | null;
        };
        /** RequestReachabilityStatus */
        RequestReachabilityStatus: {
            device?: components["schemas"]["app__schemas__device__Device-Input"] | null;
        };
        /** RetrievalLocationRequest */
        RetrievalLocationRequest: {
            device?: components["schemas"]["app__schemas__device__Device-Input"] | null;
            /** Maxage */
            maxAge?: number | null;
            /**
             * Maxsurface
             * @description Maximum surface in square meters which is accepted by the client for the location retrieval. Absence of maxSurface means "any surface size".
             */
            maxSurface?: number | null;
        };
        /** RetrieveProvisioningByDevice */
        RetrieveProvisioningByDevice: {
            device: components["schemas"]["app__schemas__device__Device-Input"] | null;
        };
        /** SendCodeBody */
        SendCodeBody: {
            /**
             * Phonenumber
             * @description A public identifier addressing a telephone subscription. In mobile networks it corresponds to the MSISDN (Mobile Station International Subscriber Directory Number). In order to be globally unique it has to be formatted in international format, according to E.164 standard, prefixed with '+'.
             */
            phoneNumber: string;
            /**
             * Message
             * @description Message template used to compose the content of the SMS sent to the phone number. It must include the following label indicating where to include the short code `{{code}}`
             */
            message: string;
        };
        /** SendCodeResponse */
        SendCodeResponse: {
            /**
             * Authenticationid
             * @description unique id of the verification attempt the code belongs to.
             */
            authenticationId: string;
        };
        /**
         * SenderSettlementMode
         * @enum {string}
         */
        SenderSettlementMode: "settled" | "unsettled";
        /**
         * ServiceClass
         * @enum {string}
         */
        ServiceClass: "microsoft_voice" | "microsoft_audio_video" | "real_time_interactive" | "multimedia_streaming" | "broadcast_video" | "low_latency_data" | "high_throughput_data" | "low_priority_data" | "standard";
        /** SinkCredential */
        SinkCredential: {
            /** @description The type of the credential. */
            credentialType: components["schemas"]["CredentialType"];
        };
        /**
         * Status
         * @enum {string}
         */
        Status: "REQUESTED" | "AVAILABLE" | "UNAVAILABLE";
        /**
         * StatusInfo
         * @enum {string}
         */
        StatusInfo: "NETWORK_TERMINATED" | "DELETE_REQUESTED";
        /** SubscriptionConfig */
        "SubscriptionConfig-Input": {
            subscriptionDetail: components["schemas"]["CreateSubscriptionDetail-Input"];
            /**
             * Subscriptionexpiretime
             * @description The subscription expiration time (in date-time format) requested by the API consumer. Up to API project decision to keep it.
             */
            subscriptionExpireTime?: string | null;
            /**
             * Subscriptionmaxevents
             * @description Identifies the maximum number of event reports to be generated (>=1) requested by the API consumer - Once this number is reached, the subscription ends. Up to API project decision to keep it.
             */
            subscriptionMaxEvents?: number | null;
            /**
             * Initialevent
             * @description Set to `true` by API consumer if consumer wants to get an event as soon as the subscription is created and current situation reflects event request.Up to API project decision to keep it.
             *     Example: Consumer subscribes to reachability SMS. If consumer sets initialEvent to true and device is already reachable by SMS, an event is triggered.
             */
            initialEvent?: boolean | null;
        };
        /** SubscriptionConfig */
        "SubscriptionConfig-Output": {
            subscriptionDetail: components["schemas"]["CreateSubscriptionDetail-Output"];
            /**
             * Subscriptionexpiretime
             * @description The subscription expiration time (in date-time format) requested by the API consumer. Up to API project decision to keep it.
             */
            subscriptionExpireTime?: string | null;
            /**
             * Subscriptionmaxevents
             * @description Identifies the maximum number of event reports to be generated (>=1) requested by the API consumer - Once this number is reached, the subscription ends. Up to API project decision to keep it.
             */
            subscriptionMaxEvents?: number | null;
            /**
             * Initialevent
             * @description Set to `true` by API consumer if consumer wants to get an event as soon as the subscription is created and current situation reflects event request.Up to API project decision to keep it.
             *     Example: Consumer subscribes to reachability SMS. If consumer sets initialEvent to true and device is already reachable by SMS, an event is triggered.
             */
            initialEvent?: boolean | null;
        };
        /** SubscriptionDetail */
        "SubscriptionDetail-Input": {
            device?: components["schemas"]["app__schemas__device__Device-Input"] | null;
            area: components["schemas"]["app__schemas__geofencing__Circle"];
        };
        /** SubscriptionDetail */
        "SubscriptionDetail-Output": {
            device?: components["schemas"]["Device-Output"] | null;
            area: components["schemas"]["Circle-Output"];
        };
        SubscriptionRequest_SubscriptionEventType_Config_: components["schemas"]["HTTPSubscriptionRequest_SubscriptionEventType_Config_"] | components["schemas"]["MQTTSubscriptionRequest_SubscriptionEventType_Config_"] | components["schemas"]["AMQPSubscriptionRequest_SubscriptionEventType_Config_"] | components["schemas"]["ApacheKafkaSubscriptionRequest_SubscriptionEventType_Config_"] | components["schemas"]["NATSSubscriptionRequest_SubscriptionEventType_Config_"];
        SubscriptionRequest_SubscriptionEventType_SubscriptionConfig_: components["schemas"]["HTTPSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["MQTTSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["AMQPSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["ApacheKafkaSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["NATSSubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"];
        /**
         * SubscriptionStatus
         * @enum {string}
         */
        SubscriptionStatus: "ACTIVATION_REQUESTED" | "ACTIVE" | "EXPIRED" | "INACTIVE" | "DELETED";
        Subscription_SubscriptionEventType_Config_: components["schemas"]["HTTPSubscriptionResponse_SubscriptionEventType_Config_"] | components["schemas"]["MQTTSubscriptionResponse_SubscriptionEventType_Config_"] | components["schemas"]["AMQPSubscriptionResponse_SubscriptionEventType_Config_"] | components["schemas"]["ApacheKafkaSubscriptionResponse_SubscriptionEventType_Config_"] | components["schemas"]["NATSSubscriptionResponse_SubscriptionEventType_Config_"];
        Subscription_SubscriptionEventType_SubscriptionConfig_: components["schemas"]["HTTPSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["MQTTSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["AMQPSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["ApacheKafkaSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_"] | components["schemas"]["NATSSubscriptionResponse_SubscriptionEventType_SubscriptionConfig_"];
        /**
         * TimeUnitEnum
         * @enum {string}
         */
        TimeUnitEnum: "Days" | "Hours" | "Minutes" | "Seconds" | "Milliseconds" | "Microseconds" | "Nanoseconds";
        /** TriggerProvisioning */
        TriggerProvisioning: {
            device: components["schemas"]["app__schemas__device__Device-Input"] | null;
            /**
             * Qosprofile
             * @description A unique name for identifying a specific QoS profile.
             *     This may follow different formats depending on the service providers implementation.
             *     Some options addresses:
             *       - A UUID style string
             *       - Support for predefined profiles QOS_S, QOS_M, QOS_L, and QOS_E
             *       - A searchable descriptive name
             *     The set of QoS Profiles that an operator is offering can be retrieved by means of the [QoS Profile API](link TBC).
             *
             */
            qosProfile: string;
            /**
             * Sink
             * @description The address to which events shall be delivered using the selected protocol.
             */
            sink?: string | null;
            sinkCredential?: components["schemas"]["SinkCredential"] | null;
        };
        /** ValidateCodeBody */
        ValidateCodeBody: {
            /**
             * Authenticationid
             * @description unique id of the verification attempt the code belongs to.
             */
            authenticationId: string;
            /**
             * Code
             * @description temporal, short code to be validated
             */
            code: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * VerificationResult
         * @enum {string}
         */
        VerificationResult: "TRUE" | "FALSE" | "PARTIAL" | "UNKNOWN";
        /** VerifyLocationRequest */
        VerifyLocationRequest: {
            device?: components["schemas"]["app__schemas__device__Device-Input"] | null;
            area: components["schemas"]["app__schemas__location__Circle"];
            /** Maxage */
            maxAge?: number | null;
        };
        /** VerifyLocationResponse */
        VerifyLocationResponse: {
            /**
             * Lastlocationtime
             * Format: date-time
             * @description Last date and time when the device was localized. It must follow RFC 3339 and must have time zone. Recommended format is yyyy-MM-dd'T'HH:mm:ss.SSSZ (i.e. which allows 2023-07-03T14:27:08.312+02:00 or 2023-07-03T12:27:08.312Z)
             */
            lastLocationTime: string;
            verificationResult: components["schemas"]["VerificationResult"];
            /**
             * Matchrate
             * @description Estimation of the match rate between the area in the request (R), and area where the network locates the device (N), calculated as the percent value of the intersection of both areas divided by the network area, that is (R ∩ N) / N * 100. Included only if VerificationResult is PARTIAL.
             */
            matchRate?: number | null;
        };
        /** Device */
        "app__schemas__device__Device-Input": {
            /** Phonenumber */
            phoneNumber?: string | null;
            /** Networkaccessidentifier */
            networkAccessIdentifier?: string | null;
            ipv4Address?: components["schemas"]["app__schemas__device__DeviceIpv4Addr"] | null;
            /** Ipv6Address */
            ipv6Address?: string | null;
        };
        /** DeviceIpv4Addr */
        app__schemas__device__DeviceIpv4Addr: {
            /**
             * Publicaddress
             * Format: ipv4
             * @description A single IPv4 address with no subnet mask
             */
            publicAddress: string;
            /** Privateaddress */
            privateAddress?: string | null;
            /** Publicport */
            publicPort?: number | null;
        };
        /** Circle */
        app__schemas__geofencing__Circle: {
            /**
             * Areatype
             * @default CIRCLE
             * @constant
             */
            areaType: "CIRCLE";
            center: components["schemas"]["Point"];
            /**
             * Radius
             * @description Expected accuracy for the subscription event of device location, in meters from `center`.
             *     Note: The area surface could be restricted locally depending on regulations. Implementations may enforce a larger minimum radius (e.g. 1000 meters).
             *
             */
            radius: number;
        };
        /**
         * SubscriptionEventType
         * @enum {string}
         */
        app__schemas__geofencing__SubscriptionEventType: "org.camaraproject.geofencing-subscriptions.v0.area-entered" | "org.camaraproject.geofencing-subscriptions.v0.area-left";
        /** Circle */
        app__schemas__location__Circle: {
            /** @default CIRCLE */
            areaType: components["schemas"]["AreaType"];
            center: components["schemas"]["Point"];
            /**
             * Radius
             * @description Distance from the center in meters
             */
            radius: number;
        };
        /** Device */
        app__schemas__qos_profiles__Device: {
            /** Phonenumber */
            phoneNumber?: string | null;
            /** Networkaccessidentifier */
            networkAccessIdentifier?: string | null;
            ipv4Address?: components["schemas"]["app__schemas__qos_profiles__DeviceIpv4Addr"] | null;
            /** Ipv6Address */
            ipv6Address?: string | null;
        };
        /**
         * DeviceIpv4Addr
         * @description The device should be identified by either the public (observed) IP address and port as seen by the application server, or the private (local) and any public (observed) IP addresses in use by the device (this information can be obtained by various means, for example from some DNS servers).
         *
         *     If the allocated and observed IP addresses are the same (i.e. NAT is not in use) then  the same address should be specified for both publicAddress and privateAddress.
         *
         *     If NAT64 is in use, the device should be identified by its publicAddress and publicPort, or separately by its allocated IPv6 address (field ipv6Address of the Device object)
         *
         *     In all cases, publicAddress must be specified, along with at least one of either privateAddress or publicPort, dependent upon which is known. In general, mobile devices cannot be identified by their public IPv4 address alone.
         */
        app__schemas__qos_profiles__DeviceIpv4Addr: components["schemas"]["DeviceIpv4Addr1"] | components["schemas"]["DeviceIpv4Addr2"];
        /**
         * SubscriptionEventType
         * @enum {string}
         */
        app__schemas__reachability_status__SubscriptionEventType: "org.camaraproject.device-reachability-status-subscriptions.v0.reachability-data" | "org.camaraproject.device-reachability-status-subscriptions.v0.reachability-sms" | "org.camaraproject.device-reachability-status-subscriptions.v0.reachability-disconnected";
    };
    responses: never;
    parameters: {
        /** @description Correlation id for the different services */
        "x-correlator": string;
    };
    requestBodies: never;
    headers: {
        /** @description Correlation id for the different services */
        "x-correlator": string;
    };
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_health_health_get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    send_code_one_time_password_sms_v1_send_code_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendCodeBody"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SendCodeResponse"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    send_code_one_time_password_sms_v1_validate_code_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ValidateCodeBody"];
            };
        };
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Problem with the client request. In addition to regular scenario of `INVALID_ARGUMENT`, another scenarios may exist:
             *       - Too many unsuccessful attempts (`{"code": "ONE_TIME_PASSWORD_SMS.VERIFICATION_FAILED","message": "The maximum number of attempts for this authenticationId was exceeded without providing a valid OTP"}`)
             *       - Expired authenticationId (`{"code": "ONE_TIME_PASSWORD_SMS.VERIFICATION_EXPIRED","message": "The authenticationId is no longer valid"}`)
             *       - OTP is not valid for the provided authenticationId (`{"code": "ONE_TIME_PASSWORD_SMS.INVALID_OTP","message": "The provided OTP is not valid for this authenticationId"}`)
             *              */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    retrieve_qos_profiles_qos_profiles_v1_retrieve_qos_profiles_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QosProfileDeviceRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QosProfile"][];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    retrieve_qos_profile_by_name_qos_profiles_v1_qos_profiles__name__get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QosProfile"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    retrieve_location_location_retrieval_v0_4_retrieve_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RetrievalLocationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Location"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    retrieve_location_location_verification_v2_verify_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifyLocationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VerifyLocationResponse"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    create_provisioning_qod_provisioning_v0_2_device_qos_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TriggerProvisioning"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProvisioningInfo"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_qod_information_by_id_qod_provisioning_v0_2_device_qos__provisioningId__get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                provisioningId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProvisioningInfo"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    delete_qod_qod_provisioning_v0_2_device_qos__provisioningId__delete: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                provisioningId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_qod_information_by_id_qod_provisioning_v0_2_retrieve_device_qos_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RetrieveProvisioningByDevice"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProvisioningInfo"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_subscription_geofencing_subscriptions_v0_4_subscriptions_get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_Config_"][];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    post_subscriptions_geofencing_subscriptions_v0_4_subscriptions_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SubscriptionRequest_SubscriptionEventType_Config_"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_Config_"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_subscriptions_by_id_geofencing_subscriptions_v0_4_subscriptions__subscriptionId__get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_Config_"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    delete_subscriptions_by_id_geofencing_subscriptions_v0_4_subscriptions__subscriptionId__delete: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    retrieve_reachability_status_device_reachability_status_v1_retrieve_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestReachabilityStatus"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReachabilityStatusResponse"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_subscription_device_reachability_status_subscriptions_v0_7_subscriptions_get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_SubscriptionConfig_"][];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    post_subscriptions_device_reachability_status_subscriptions_v0_7_subscriptions_post: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SubscriptionRequest_SubscriptionEventType_SubscriptionConfig_"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_SubscriptionConfig_"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    get_subscriptions_by_id_device_reachability_status_subscriptions_v0_7_subscriptions__subscriptionId__get: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription_SubscriptionEventType_SubscriptionConfig_"];
                };
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
    delete_subscriptions_by_id_device_reachability_status_subscriptions_v0_7_subscriptions__subscriptionId__delete: {
        parameters: {
            query?: never;
            header?: {
                /** @description Correlation id for the different services */
                "x-correlator"?: components["parameters"]["x-correlator"];
            };
            path: {
                subscriptionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Problem with the client request */
            400: {
                headers: {
                    "x-correlator": components["headers"]["x-correlator"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorInfo"];
                };
            };
        };
    };
}
